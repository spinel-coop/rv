use regex::Regex;
use std::borrow::Cow;

use anstream::println;
use camino::Utf8PathBuf;
use miette::Diagnostic;
use once_cell::sync::Lazy;
use owo_colors::OwoColorize;

use rv_ruby::request::RubyRequest;
use rv_ruby::request::Source;

use crate::{GlobalArgs, config::Config};

static RUBY_TOOL_VERSIONS_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"^ *ruby ").unwrap());

#[derive(Debug, thiserror::Error, Diagnostic)]
pub enum Error {
    #[error("No Ruby version request found in {}", path.cyan())]
    NoRubyRequest { path: Utf8PathBuf },
    #[error(transparent)]
    ConfigError(#[from] crate::config::Error),
    #[error(transparent)]
    IoError(#[from] std::io::Error),
}

type Result<T> = miette::Result<T, Error>;

pub(crate) fn pin(global_args: &GlobalArgs, request: Option<RubyRequest>) -> Result<()> {
    let config = &Config::new(global_args, None)?;

    match request {
        None => show_pinned_ruby(config),
        Some(request) => set_pinned_ruby(config, request),
    }
}

fn set_pinned_ruby(config: &Config, request: RubyRequest) -> Result<()> {
    let version = request.to_tool_consumable_version();
    let project_dir: Cow<Utf8PathBuf> = match config.requested_ruby {
        Some((_, Source::DotToolVersions(ref path))) => {
            let versions = fs_err::read_to_string(path)?;
            let mut new_versions = String::new();
            let mut wrote_ruby = false;

            for line in versions.lines() {
                if let Some(found) = RUBY_TOOL_VERSIONS_REGEX.find(line) {
                    new_versions.push_str(&format!("{}{version}", found.as_str()));
                    wrote_ruby = true;
                } else {
                    new_versions.push_str(line);
                }
                if !wrote_ruby {
                    new_versions.push_str(&format!("ruby {version}"));
                }
                new_versions.push('\n');
            }

            fs_err::write(path, new_versions)?;
            Cow::Borrowed(path)
        }
        Some((_, Source::DotRubyVersion(ref path))) => {
            fs_err::write(path, format!("{version}\n"))?;
            Cow::Borrowed(path)
        }
        Some((_, Source::GemfileLock(_))) | Some((_, Source::Other)) | None => {
            // For Gemfile.lock source, create a .ruby-version file instead of
            // modifying the lockfile (which is auto-generated by bundler)
            let path = config.current_dir.join(".ruby-version");
            fs_err::write(&path, format!("{version}\n"))?;
            Cow::Owned(path)
        }
    };

    println!("{0} pinned to {1}", project_dir.cyan(), version.cyan());

    Ok(())
}

fn show_pinned_ruby(config: &Config) -> Result<()> {
    let Some((ruby, source)) = &config.requested_ruby else {
        return Err(Error::NoRubyRequest {
            path: config.current_dir.clone(),
        });
    };

    let dir: Cow<Utf8PathBuf> = match source {
        Source::DotToolVersions(path) => Cow::Borrowed(path),
        Source::DotRubyVersion(path) => Cow::Borrowed(path),
        Source::GemfileLock(path) => Cow::Borrowed(path),
        Source::Other => {
            let ruby_version_path = config.current_dir.join(".ruby-version");
            Cow::Owned(ruby_version_path)
        }
    };

    let version = ruby.to_tool_consumable_version();
    println!("{0} is pinned to {1}", dir.as_ref().cyan(), version.cyan());
    Ok(())
}

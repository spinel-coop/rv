use std::borrow::Cow;
use std::str::FromStr;

use anstream::println;
use camino::Utf8PathBuf;
use miette::Diagnostic;
use owo_colors::OwoColorize;

use rv_ruby::request::RubyRequest;
use rv_ruby::request::Source;

use crate::config::Config;

#[derive(Debug, thiserror::Error, Diagnostic)]
pub enum Error {
    #[error("No Ruby version request found in {}", path.cyan())]
    NoRubyRequest { path: Utf8PathBuf },
    #[error(transparent)]
    InvalidVersion(#[from] rv_ruby::request::RequestError),
    #[error(transparent)]
    IoError(#[from] std::io::Error),
}

type Result<T> = miette::Result<T, Error>;

pub fn pin(config: &Config, version: Option<String>) -> Result<()> {
    match version {
        None => show_pinned_ruby(config),
        Some(version) => set_pinned_ruby(config, version),
    }
}

fn set_pinned_ruby(config: &Config, version: String) -> Result<()> {
    let requested_version = RubyRequest::from_str(&version)?;

    let project_dir: Cow<Utf8PathBuf> = match config.requested_ruby {
        Some((_, Source::DotToolVersions(ref path))) => {
            let versions = fs_err::read_to_string(path)?;
            let mut new_versions = String::new();
            let mut wrote_ruby = false;
            for line in versions.lines() {
                if line.starts_with("ruby ") {
                    new_versions.push_str(&format!("ruby {version}"));
                    wrote_ruby = true;
                } else {
                    new_versions.push_str(line);
                }
                if !wrote_ruby {
                    new_versions.push_str(&format!("ruby {version}"));
                }
                new_versions.push('\n');
            }

            fs_err::write(path, new_versions)?;
            Cow::Borrowed(path)
        }
        Some((_, Source::DotRubyVersion(ref path))) => {
            fs_err::write(path, format!("{version}\n"))?;
            Cow::Borrowed(path)
        }
        Some((_, Source::GemfileLock(_))) | Some((_, Source::Other)) | None => {
            // For Gemfile.lock source, create a .ruby-version file instead of
            // modifying the lockfile (which is auto-generated by bundler)
            let path = config.current_dir.join(".ruby-version");
            fs_err::write(&path, format!("{version}\n"))?;
            Cow::Owned(path)
        }
    };

    println!(
        "{0} pinned to {1}",
        project_dir.cyan(),
        requested_version.cyan()
    );

    Ok(())
}

fn show_pinned_ruby(config: &Config) -> Result<()> {
    let Some((ruby, source)) = &config.requested_ruby else {
        return Err(Error::NoRubyRequest {
            path: config.current_dir.clone(),
        });
    };

    let dir: Cow<Utf8PathBuf> = match source {
        Source::DotToolVersions(path) => Cow::Borrowed(path),
        Source::DotRubyVersion(path) => Cow::Borrowed(path),
        Source::GemfileLock(path) => Cow::Borrowed(path),
        Source::Other => {
            let ruby_version_path = config.current_dir.join(".ruby-version");
            Cow::Owned(ruby_version_path)
        }
    };

    println!("{0} is pinned to {1}", dir.as_ref().cyan(), ruby.cyan());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_fs::TempDir;
    use camino::Utf8PathBuf;
    use indexmap::indexset;

    fn test_config() -> Result<Config> {
        let root = Utf8PathBuf::from(TempDir::new().unwrap().path().to_str().unwrap());
        let ruby_dir = root.join("opt/rubies");
        fs_err::create_dir_all(&ruby_dir)?;
        let current_dir = root.join("project");
        fs_err::create_dir_all(&current_dir)?;

        let config = Config {
            ruby_dirs: indexset![ruby_dir],
            current_exe: root.join("bin").join("rv"),
            requested_ruby: Some(("3.5.0".parse().unwrap(), Source::Other)),
            current_dir,
            cache: rv_cache::Cache::temp().unwrap(),
            root,
        };

        Ok(config)
    }

    #[test]
    fn test_pin_runs_with_no_version() {
        let mut config = test_config().unwrap();
        config.requested_ruby = None;
        pin(&config, None).expect_err("No Ruby request found");
    }

    #[test]
    fn test_pin_runs_with_ruby_version() {
        let mut config = test_config().unwrap();

        let ruby_version_file = config.current_dir.join(".ruby-version");
        config.requested_ruby = Some((
            "3.2.0".parse().unwrap(),
            Source::DotRubyVersion(ruby_version_file),
        ));
        pin(&config, None).unwrap();
    }

    #[test]
    fn test_pin_runs_with_tool_versions() {
        let mut config = test_config().unwrap();

        pin(&config, None).unwrap();
        let version_file = config.current_dir.join(".tool-versions");
        config.requested_ruby = Some((
            "3.2.0".parse().unwrap(),
            Source::DotToolVersions(version_file),
        ));
        pin(&config, None).unwrap();
    }

    #[test]
    fn test_pin_ruby_creates_file_when_requested_version_is_valid() {
        let config = test_config().unwrap();
        let version = "3.2.0".to_string();

        // Should not panic - basic smoke test
        pin(&config, Some(version.clone())).unwrap();

        // Verify the file was created
        let ruby_version_path = config.current_dir.join(".ruby-version");
        assert!(ruby_version_path.exists());
        let content = fs_err::read_to_string(ruby_version_path).unwrap();
        assert_eq!(content, format!("{version}\n"));
    }

    #[test]
    fn test_pin_ruby_does_not_create_file_when_requested_version_is_invalid() {
        let config = test_config().unwrap();
        let version = "3.2.0.4.5".to_string();

        // Should panic - basic smoke test
        pin(&config, Some(version.clone())).expect_err(&format!(
            "Expected invalid version {version} to be rejected, but was accepted"
        ));

        // Verify the file was not created
        let ruby_version_path = config.current_dir.join(".ruby-version");
        assert!(!ruby_version_path.exists());
    }

    #[test]
    fn test_pin_ruby_overwrites_existing_ruby_version_file() {
        let config = test_config().unwrap();
        let first_version = "3.0.0".to_string();
        let second_version = "3.2.0".to_string();

        // Pin first version
        pin(&config, Some(first_version)).unwrap();

        // Pin second version (should overwrite)
        pin(&config, Some(second_version.clone())).unwrap();

        // Verify the file contains the second version
        let ruby_version_path = config.current_dir.join(".ruby-version");
        let content = fs_err::read_to_string(ruby_version_path).unwrap();
        assert_eq!(content, format!("{second_version}\n"));
    }

    #[test]
    fn test_pin_ruby_overwrites_existing_tool_versions_file() {
        let mut config = test_config().unwrap();
        let version_file = config.current_dir.join(".tool-versions");
        config.requested_ruby = Some((
            "3.2.0".parse().unwrap(),
            Source::DotToolVersions(version_file.clone()),
        ));

        fs_err::write(&version_file, "ruby 3.0.0").unwrap();

        // Pin version (should overwrite)
        pin(&config, Some("3.4.0".to_string())).unwrap();

        // Verify the file contains the second version
        let content = fs_err::read_to_string(&version_file).unwrap();
        assert_eq!(content, "ruby 3.4.0\n");
    }

    #[test]
    fn test_pin_ruby_with_prerelease_version() {
        let config = test_config().unwrap();
        let version = "3.3.0-preview1".to_string();

        pin(&config, Some(version.clone())).unwrap();

        let ruby_version_path = config.current_dir.join(".ruby-version");
        let content = fs_err::read_to_string(ruby_version_path).unwrap();
        assert_eq!(content, format!("{version}\n"));
    }

    #[test]
    fn test_pin_ruby_with_patch_version() {
        let config = test_config().unwrap();
        let version = "1.9.2-p0".to_string();

        pin(&config, Some(version.clone())).unwrap();

        let ruby_version_path = config.current_dir.join(".ruby-version");
        let content = fs_err::read_to_string(ruby_version_path).unwrap();
        assert_eq!(content, format!("{version}\n"));
    }
}
